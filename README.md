# Early Stage Diabetes Risk Prediction Model

## Project Overview
This project implements a comprehensive machine learning pipeline for predicting early-stage diabetes risk using clinical symptoms. The model utilizes logistic regression with advanced statistical validation techniques to provide interpretable and reliable predictions. This project is based on the analysis performed in the `notebooks/early-stage-diabetes-risk-prediction.ipynb` notebook.

## Project Structure
The repository is organized as follows:
```
├── notebooks/
│   └── early-stage-diabetes-risk-prediction.ipynb  # Jupyter notebook with data analysis and model training
├── saved_models/                                 # Directory for storing saved model artifacts (e.g., .pkl files)
├── .gitignore                                    # Specifies intentionally untracked files that Git should ignore
├── LICENSE                                       # Contains the MIT license for the project
├── README.md                                     # This file, providing an overview of the project
└── requirements.txt                              # Lists Python dependencies for reproducibility
```
*(Note: A `data/` directory can be created for users who download data locally. A `src/` directory can be added for Python scripts if the project expands beyond the notebook.)*

## Dataset
- **Source**: The dataset used is `diabetes_data_upload.csv`, which is part of the "Early Diabetes Classification" dataset available on Kaggle. It can be found at: [https://www.kaggle.com/datasets/andrewmvd/early-diabetes-classification](https://www.kaggle.com/datasets/andrewmvd/early-diabetes-classification)
- **Samples**: 520 patients
- **Description**: The dataset contains information on 520 patients, including 16 clinical symptoms and demographic data, aimed at predicting the early presence of diabetes.

## Features
The model uses the following 18 features (16 original + 2 derived):
- Age (Numeric)
- Gender (Categorical: Male/Female, encoded as 0/1)
- Polyuria (Binary: Yes/No, encoded as 1/0)
- Polydipsia (Binary: Yes/No, encoded as 1/0)
- Sudden weight loss (Binary: Yes/No, encoded as 1/0)
- Weakness (Binary: Yes/No, encoded as 1/0)
- Polyphagia (Binary: Yes/No, encoded as 1/0)
- Genital thrush (Binary: Yes/No, encoded as 1/0)
- Visual blurring (Binary: Yes/No, encoded as 1/0)
- Itching (Binary: Yes/No, encoded as 1/0)
- Irritability (Binary: Yes/No, encoded as 1/0)
- Delayed healing (Binary: Yes/No, encoded as 1/0)
- Partial paresis (Binary: Yes/No, encoded as 1/0)
- Muscle stiffness (Binary: Yes/No, encoded as 1/0)
- Alopecia (Binary: Yes/No, encoded as 1/0)
- Obesity (Binary: Yes/No, encoded as 1/0)
- `symptom_count` (Numeric, derived): Sum of the 14 binary symptom features (Polyuria to Obesity).
- `age_obesity_interaction` (Numeric, derived): Product of Age and Obesity (encoded).

## Target Variable
- **Class**: Early-stage diabetes (Binary classification: Positive/Negative, encoded as 1/0).

## Model
- **Algorithm**: Logistic Regression
- **Preprocessing**:
    - Data Cleaning (handling outliers, consistent column names)
    - Categorical to Numeric Conversion
    - Feature Scaling (StandardScaler)
    - Handling Class Imbalance (SMOTE - Synthetic Minority Over-sampling Technique)
- **Model Persistence**: The trained pipeline, scaler, and model coefficients are generated by the notebook and should be saved in the `saved_models/` directory:
    - `diabetes_predictor_v2.pkl` (the full scikit-learn pipeline)
    - `diabetes_scaler.pkl` (the StandardScaler object)
    - `diabetes_model_coefficients.pkl` (intercept, coefficients, and feature names for interpretability)

## Evaluation Metrics
The model's performance is evaluated using the following metrics (detailed in the notebook):
- ROC AUC Score
- Sensitivity (True Positive Rate, Recall)
- Specificity (True Negative Rate)
- Positive Predictive Value (PPV, Precision)
- Negative Predictive Value (NPV)
- F1-Score
- Confusion Matrix
- Classification Report
- Log-Likelihood, AIC (Akaike Information Criterion), BIC (Bayesian Information Criterion)
- Advanced Cross-Validation Techniques (Repeated Stratified K-Fold, Nested CV, Learning Curves, Bootstrap Validation)

## Results
The model demonstrates excellent performance in predicting early-stage diabetes risk:
- **Cross-validation ROC AUC (5-Fold Stratified CV on resampled data)**: 0.9807 ± 0.0101
- **Test Set Performance**:
    - ROC AUC Score: 0.9932
    - Sensitivity (Recall): 0.9531
    - Specificity: 0.9844
    - Precision (PPV): 0.9839
    - NPV: 0.9545
    - Accuracy: 0.97
- **Model Interpretability Metrics**:
    - Log-Likelihood: -14.8861
    - AIC: 67.7722
    - BIC: 121.9608
- The notebook (`notebooks/early-stage-diabetes-risk-prediction.ipynb`) provides further details on coefficient analysis, odds ratios, and feature stability.

## Installation / Setup
To set up the environment and run this project:

1.  **Clone the repository:**
    ```bash
    # git clone <repository-url>
    # cd <repository-name>
    ```
    (Replace `<repository-url>` and `<repository-name>` with actual values)
2.  **Create a virtual environment (recommended):**
    ```bash
    python -m venv venv
    source venv/bin/activate  # On Windows use `venv\Scripts\activate`
    ```
3.  **Install dependencies:**
    The necessary Python libraries are listed in `requirements.txt`. Install them using pip:
    ```bash
    pip install -r requirements.txt
    ```
4.  **Obtain Saved Models:**
    Run the Jupyter notebook `notebooks/early-stage-diabetes-risk-prediction.ipynb` to train the model and generate the `.pkl` files. Ensure these generated files (`diabetes_predictor_v2.pkl`, `diabetes_scaler.pkl`, `diabetes_model_coefficients.pkl`) are placed in the `saved_models/` directory.
5.  **Explore the Notebook:**
    Launch Jupyter Lab or Jupyter Notebook to explore the data analysis, model training, and evaluation:
    ```bash
    jupyter lab
    # Then open notebooks/early-stage-diabetes-risk-prediction.ipynb
    ```

## How to Use
The trained model can be loaded and used to make predictions on new patient data. Ensure the model files (`diabetes_predictor_v2.pkl`, `diabetes_scaler.pkl`, `diabetes_model_coefficients.pkl`) are in the `saved_models/` directory.

```python
import pandas as pd
import numpy as np
import joblib
import os # For constructing path

# --- Load Model and Helper Objects ---
# Ensure these files are in the 'saved_models/' directory relative to this script
models_path = "saved_models/"
pipeline = joblib.load(os.path.join(models_path, 'diabetes_predictor_v2.pkl'))
saved_scaler = joblib.load(os.path.join(models_path, 'diabetes_scaler.pkl'))
model_coefficients = joblib.load(os.path.join(models_path, 'diabetes_model_coefficients.pkl'))

# --- Helper Functions (from notebook) ---
def calculate_odds(probability):
    # Calculate odds from probability: p/(1-p)
    # Added epsilon for stability if probability is exactly 1.0
    return probability / (1 - probability + 1e-15)

# --- Optimal Thresholds (derived from notebook analysis) ---
# These values are based on Youden's J statistic for ROC and F1-optimal for PR curve.
# For a simple classification, a standard 0.5 threshold can also be used.
optimal_threshold_roc = 0.3666
optimal_threshold_pr = 0.3666

# --- Main Prediction Function ---
def predict_diabetes_status(age, gender, polyuria, polydipsia, sudden_weight_loss,
                           weakness, polyphagia, genital_thrush, visual_blurring,
                           itching, irritability, delayed_healing, partial_paresis,
                           muscle_stiffness, alopecia, obesity,
                           symptom_count, age_obesity_interaction):

    feature_names = ['age', 'gender', 'polyuria', 'polydipsia', 'sudden weight loss',
                     'weakness', 'polyphagia', 'genital thrush', 'visual blurring',
                     'itching', 'irritability', 'delayed healing', 'partial paresis',
                     'muscle stiffness', 'alopecia', 'obesity', 'symptom_count',
                     'age_obesity_interaction']

    input_data_dict = {
        'age': age, 'gender': gender, 'polyuria': polyuria, 'polydipsia': polydipsia,
        'sudden weight loss': sudden_weight_loss, 'weakness': weakness, 'polyphagia': polyphagia,
        'genital thrush': genital_thrush, 'visual blurring': visual_blurring, 'itching': itching,
        'irritability': irritability, 'delayed healing': delayed_healing, 'partial paresis': partial_paresis,
        'muscle stiffness': muscle_stiffness, 'alopecia': alopecia, 'obesity': obesity,
        'symptom_count': symptom_count, 'age_obesity_interaction': age_obesity_interaction
    }

    input_df = pd.DataFrame([input_data_dict], columns=feature_names)
    probability_positive = pipeline.predict_proba(input_df)[0][1]
    odds_positive = calculate_odds(probability_positive)

    # For logit and feature contributions, scale the input as the raw model expects scaled data
    input_scaled_array = saved_scaler.transform(input_df)
    logit_calculated = model_coefficients['intercept'] + np.sum(model_coefficients['coefficients'] * input_scaled_array[0])

    feature_contributions = {}
    for i, feature in enumerate(feature_names):
        contribution = model_coefficients['coefficients'][i] * input_scaled_array[0][i]
        feature_contributions[feature] = contribution

    sorted_contributions = sorted(feature_contributions.items(), key=lambda x: abs(x[1]), reverse=True)

    classifications = {
        'default_0.5_threshold': 'High Risk (Positive)' if probability_positive > 0.5 else 'Low Risk (Negative)',
        'roc_optimal_threshold': 'High Risk (Positive)' if probability_positive > optimal_threshold_roc else 'Low Risk (Negative)',
        'pr_optimal_threshold': 'High Risk (Positive)' if probability_positive > optimal_threshold_pr else 'Low Risk (Negative)'
    }

    return {
        'input_features': input_df.iloc[0].to_dict(),
        'probability_positive_percent': round(probability_positive * 100, 2),
        'odds_positive': round(odds_positive, 2),
        'logit_calculated': round(logit_calculated, 4),
        'classifications': classifications,
        'top_5_contributors_to_logit': [
            {'feature': f, 'contribution': round(c, 4)} for f, c in sorted_contributions[:5]
        ]
    }

# Example Usage:
# Define input values for a patient (same as notebook example)
patient_age = 45; patient_gender = 0; patient_polyuria = 1; patient_polydipsia = 1;
patient_sudden_weight_loss = 0; patient_weakness = 1; patient_polyphagia = 0;
patient_genital_thrush = 0; patient_visual_blurring = 1; patient_itching = 0;
patient_irritability = 0; patient_delayed_healing = 0; patient_partial_paresis = 0;
patient_muscle_stiffness = 0; patient_alopecia = 1; patient_obesity = 0;

# Calculate derived features for the example
binary_symptom_names = ['polyuria', 'polydipsia', 'sudden weight loss', 'weakness',
                        'polyphagia', 'genital thrush', 'visual blurring', 'itching',
                        'irritability', 'delayed healing', 'partial paresis',
                        'muscle stiffness', 'alopecia', 'obesity']
example_symptoms_for_count = {
    'polyuria': patient_polyuria, 'polydipsia': patient_polydipsia,
    'sudden weight loss': patient_sudden_weight_loss, 'weakness': patient_weakness,
    'polyphagia': patient_polyphagia, 'genital thrush': patient_genital_thrush,
    'visual blurring': patient_visual_blurring, 'itching': patient_itching,
    'irritability': patient_irritability, 'delayed healing': patient_delayed_healing,
    'partial paresis': patient_partial_paresis, 'muscle stiffness': patient_muscle_stiffness,
    'alopecia': patient_alopecia, 'obesity': patient_obesity
}
patient_symptom_count = sum(example_symptoms_for_count[symptom] for symptom in binary_symptom_names)
patient_age_obesity_interaction = patient_age * patient_obesity

# Make a prediction
try:
    prediction_example = predict_diabetes_status(
        age=patient_age, gender=patient_gender, polyuria=patient_polyuria,
        polydipsia=patient_polydipsia, sudden_weight_loss=patient_sudden_weight_loss,
        weakness=patient_weakness, polyphagia=patient_polyphagia,
        genital_thrush=patient_genital_thrush, visual_blurring=patient_visual_blurring,
        itching=patient_itching, irritability=patient_irritability,
        delayed_healing=patient_delayed_healing, partial_paresis=patient_partial_paresis,
        muscle_stiffness=patient_muscle_stiffness, alopecia=patient_alopecia,
        obesity=patient_obesity,
        symptom_count=patient_symptom_count,
        age_obesity_interaction=patient_age_obesity_interaction
    )

    print("--- Example Patient Prediction ---")
    # print(f"Input Features: {prediction_example['input_features']}") # Verbose
    print(f"Probability of Diabetes (Positive Class): {prediction_example['probability_positive_percent']}%")
    print(f"Odds of Diabetes (Positive Class): {prediction_example['odds_positive']}")
    print(f"Calculated Logit: {prediction_example['logit_calculated']}")
    print(f"Classifications based on various thresholds: {prediction_example['classifications']}")
    print("\nTop 5 Contributors to Logit (Prediction Score):")
    for item in prediction_example['top_5_contributors_to_logit']:
        print(f"  - Feature: {item['feature']}, Contribution: {item['contribution']}")
except FileNotFoundError:
    print("Model files not found in saved_models/ directory. Please run the notebook to generate them or place them there.")
except Exception as e:
    print(f"An error occurred during prediction: {e}")

```

## Model Limitations
1.  **Self-Reported Data**: The model is based on symptoms that may be self-reported, which can introduce bias or inaccuracies.
2.  **Focus on Early Stage**: The prediction is specifically for early-stage diabetes and may not generalize well to other stages or types of diabetes.
3.  **Feature Set**: Performance is limited to the 18 features (16 original + 2 derived) used in this dataset. Other unobserved factors could influence diabetes risk.
4.  **External Validation**: The model requires validation on new, diverse datasets and populations to confirm its broader applicability and robustness.
5.  **SMOTE**: Class imbalance was addressed using SMOTE. While effective, synthetic data generation can sometimes influence model behavior on real-world, naturally distributed data.

## Author
- Ahmed Yassin Mohammed

## Date
- May 31, 2025 (as per notebook metadata)

## Version
- 2.0 (as per notebook metadata)

## License
This project is licensed under the MIT License. See the `LICENSE` file for details.
